#include <bits/stdc++.h>
using namespace std;

int main() {
    int N, M;
    cin >> N >> M;

    vector<vector<int>> vec(M); //M行正則行列で初期化

    for(int i = 0; i < M; ++i) {
        int k;
        cin >> k;
        vec[i].resize(k); 
        for(int j = 0; j < k; ++j) {
            cin >> vec[i][j];
            --vec[i][j];
        }
    }
    //まず入力を受け取るところが参考になる。
    //M行M列で初期化→kを受け取り、リサイズ→与えられる数が1からなので0からにする。

    vector<int> p(M);
    for (int i = 0; i < M; ++i) {
        cin >> p[i];
    }

    int ans = 0;
    for(int i  = 0; i < (1<<N); ++i) {
        //(1<<N)をすることによって、例えばN=３の時、1<<3は8になる。これは000,001,010,011,100,101,110,111の組み合わせを全て表現できている。
        //つまり最初のループでは000を考えて、2回目は001を考えて...のようにつながっていく。
        //2の累乗はビットシフトで計算したほうが早い。

        bool ok = true;
        for(int j = 0; j < M; ++j) {
            //電球の数だけ回す。
            int c = 0;
            //cは今考えている電球につながっているスイッチがいくつonになっているのか。
            for(int k = 0; k < vec[j].size(); ++k) { 
                int id  = vec[j][k];
                //idは何番目のスイッチにつながっているのかを表している。

                //このfor文を範囲forで記述すると、for(int id : vec[j])だけで済む。行を指定して、要素を一つ一つとっているだけだと考えればそう難しいことはない。
                if((i>>id) & 1) {
                    //iは000,001,010,011,100,101,110,111の順でくる。
                    //だから電球の考えている番号は012ではなく、210の順ってこと。
                    //例えば、0の電球と2のスイッチがつながっていたとする。0の電球を考えているとき、idは2になる。
                    //iが3の時,100を右に2シフトだから1になる。これは正しいので1が追加される。
                    ++c;
                }
            }
            c %= 2;
            if(c != p[j]){
                //どこかのタイミングでpと一致していなかったらfalseになる。
                ok = false;
            }
        }
        if(ok) {
            ++ans;
        }
    }
    cout << ans << endl;
    return 0;
}