#include <bits/stdc++.h>
using namespace std;

int main() {
    //bit全探索の基本となる考え方は,組み合わせが2の累乗である時ビットシフトを使ってfor文を作れってことだと理解している。
    //今回もビットシフトでfor文を回すことは多分あっているのだけれども、どのような条件でmax人数を判定すれば良いのかがわからない。

    //0が嘘つきならどうなるのか？発展課題。
    //有向グラフで解説は考えている。

    //方針：
    //不親切な人だと仮定した人の証言はなんでも良い。正直者と不親切な人を決め打つ。
    //不親切から伸びる矢印はなんでも良い。ここの発想が出てこなかった。
    //正直者から伸びる矢印は全部が正しくないといけない。ここで判定するのか！！！
    //Nは１５以下なので、割り当ての通りは2^15 〜＝ 10^4*3　になる。
    //証言の数がN^2個なので計算量は最大でも2^15*15^2になる。


    //証言を有向グラフの形で入力する。g[i][j]の有向グラフはi->jの順に矢印が向いている。これむっちゃ大事やな。
    int g[15][15];
    int n;
    cin >> n;
    for(int i = 0; i < n; ++i) {
        for(int j = 0; j < n; ++j) {
            g[i][j] = -1; //証言していないということを-1で初期化する。
        }
    }

    //N人いるのでN回繰り返して入力を受け取る
    for(int i = 0; i < n; ++i) {
        int m;
        cin >> m; //入力のAにあたる。
        for(int j = 0; j < m; ++j) {
            int a, x;
            cin >> a >> x; //入力のxとyにあたる。
            --a; //人のインデックスが1から始まっているため。
            g[i][a] = x;
        }
    }

    int ans = 0; //大体2の冪乗を全て試す時はansを別個で用意してそこに加算か、入れ替えをしていく。

    for(int i = 0; i < (1 << n); i++) {
        //10 => 001010；1が立っているものを正直者を表している。とする。
        vector<int> d(n); //誰が正直者かをベクトルで表現し直している。

        //誰が正直者(1)なのかを代入するだけなので、n回のループで良い。
        for(int j = 0; j < n; ++j) {
            if(i >> j & 1) { //iのjbit目が1であるかどうかを判定している。例えば、i=10の時、001010になる。これをj=1bitだけずらしてみると、000101になる。
                d[j] = 1;    //これと000001のandをとると、先ほどの文の通り、iのjbit目が1であるかどうかを判定している。だから、人1とdのインデックスが対応している。
            }
        }  //正直者と不親切な人の割り当てを d に入れた
        //正直者と割り当てた人の証言を全てチェックする。
        bool ok = true;
        for(int j = 0; j < n; ++j) {
            if(d[j]){
                for(int k = 0; k < n; ++k) {
                    if(g[j][k] == -1) continue;
                    if(g[j][k] != d[k]) { 
                        ok = false;
                    }
                }
            }
        }
        if(ok) {
            ans = max(ans, __builtin_popcount(i)); //今は__popcount は１０進数の数を受け取り、2進数に直した時に１が何個立っているのかを取得する。
        }
    }
    cout << ans << endl;
    return 0;
}