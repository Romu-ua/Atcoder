#include <bits/stdc++.h>
using namespace std;

/*
なんらかの全探索はしたいが、単に探索するのは無理。
スタート地点を決めて、どのぐらい伸ばせるか？ -> なるほどねー。bit全探索かと思った。
しかし、毎回どのぐらい伸ばせるのか？を確かめているとo(N^2)になる。
右端を２分探索する。２分探索はあるところまではYesであるところからNoになる列に対して、
その境界を見つけるのに使う。単調性、があるときに使える。
今回は単調性がある。

〇〇〇〇XXX
↑→   ↑↑ ←↑
差が１になるところをまで見つける。

今回の⚪︎かXかの条件は . の個数が K 以下。
しかし、.の個数も高速に求める必要がある。
累積和でできる。累積和は先頭からの和であるから
末尾ひくスタート位置の累積和をしてあげる。

今回むずいな。
スタート位置を決めて全探索
→左端を２分探索
→ . の個数を求めるために累積和。


より賢い方法がある。
とりあえず01列にすると、問題が「和がkを超えない最大の区間を求める」になる。
尺取法。これも単調性があるから。
一個減らす→伸ばせるところまで伸ばす→一個減らす→・・・右端に着いたらおしまい。
最大の区間を保存しておいて。
左端が動くのは高々N回。
*/

int main() {
    string s;
    int k;
    cin >> s >> k;
    int n = s.size();

    //01列に変換
    vector<int> a(n);
    for(int i = 0; i < n; i++) {
        if(s[i] == '.') {
            a[i] = 1;
        } else {
            a[i] = 0;
        }
    }

    int ans = 0;
    int r = 0, sum = 0; //sumは現在の区間の .(1)の数。
    for(int l = 0; l < n; l++) {
        while(r < n && sum + a[r] <= k) {
            sum += a[r]; //右端を進める。
            ++r;
        }
        ans = max(ans, r-l); // r-lをsumにすると、.の個数と入れているだけ。sumは。の数。
        sum -= a[l];//左端を進める。
    }

    cout << ans << endl;
    return 0;
}








