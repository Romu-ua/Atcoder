#include <bits/stdc++.h>
using namespace std;

/*
パターン数がすでにn^4
盤面の判定はn^2ぐらいかかる。これを実装するとn^6になる。

なので、塗る場所を探索する範囲を削減する。
「６連続ができる可能性のある場所を全部試す。」
これは、基準点を定めてあげるイメージを持っていれば、フィールドの全てのマスが基準点になり得るので、n^2
また縦横斜めがあるから実際には*４されているイメージ。

上ができるかの条件は白が2個以下。

実装上の注意。
４通りあるので、それぞれ実装するとめんどくさい。
処理を共通化させたい。
基準を決めた時に、見ていく方向が違う。見ていく向きだけが異なるので、これを４通り書く。
また、横縦、斜めで共通化させることもできる。転置することで共通化できる。
しかし、斜めがあるので、向きで見て行ったほうがいいかも。
*/

int main() {
    // 進む向きを作ってあげる。
    const int di[4] = {0, 1, 1, -1}  ;
    const int dj[4] = {1, 0, 1, 1};

    int n;
    cin >> n;
    vector<string> s(n);
    for (int i = 0; i < n; i++){
        cin >> s[i];
    }

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            for (int v = 0; v < 4; v++) {
                // 今見ている場所。
                int ni = i, nj = j;
                // 白の個数のカウント
                int cnt = 0;
                // ６個見ていく
                for (int k = 0; k < 6; k++) {
                    if (ni < 0 || n <= ni || nj < 0 || n <= nj) {
                        cnt = 99999999;
                        break;
                    }
                    if (s[ni][nj] == '.') cnt++;
                    ni += di[v], nj += dj[v];
                }
                if (cnt <= 2) {
                    cout << "Yes" <<endl;
                    return 0;
                } 
            }
        }
    }
    cout << "No" << endl;
    return 0;
}