#include <bits/stdc++.h>
using namespace std;

/*
木を作るのはできない
計算で頂点番号を求めたい。
答えが10^18に収まるが、途中が10^18に収まるとは言っていない。
例えばLL...Lとかだと2^Lの回数分になってしまう。これは無理。

解法１：
操作を整理する。
例えば、LU、RUという操作は無意味、なのでこれを削除する。
しかし、これをそのままやると、最悪文字列の長さ分かかるからn^2ぐらいかかる。

例えばUU...U RLRLRLLLRRのような文字列の時、
最初は単調に減り、次は単調に増える。この時、単調増加なので、この時の最大値は最後、で答えは10^18なのでlong long で収まる。
また、この考察はUがいずれも /2 であることと、RLの増加が異なることから、Uをまとめても結果に影響がないことも考慮している。気がする説明はしてなかったけど。

では先ほどのような並びに高速にする方法を考える。
Uを先頭に持ってくるのではなくて、LかRを消す。
LU、RUが無害ということと、単調増加、単調増加にすること、この２つがわかっていれば解けた。
末尾の追加と削除が高速に行えるデータ構造を使う。

解法２：
2進数で考える。
完全２分木において、頂点を２進数で考えると、
×２は末尾に０を追加したもの、
×2+1は末尾に１を追加したもの。
/2は末尾を削除する。
*/

int main() {
    int n;
    long long x;
    cin >> n >> x;
    string s;
    cin >> s;

    string t;
    for (char c : s) {
        if (c == 'U') {
            if (t.size() > 0 && t.back() != 'U') {
                t.pop_back();
            } else {
                t += c;
            }
        } else {
            t += c;
        }
    }

    for (char c : t) {
        if (c == 'U') x /= 2;
        if (c == 'L') x *= 2;
        if (c == 'R') x = x*2+1; 
    }
    cout << x << endl;
    return 0;
}